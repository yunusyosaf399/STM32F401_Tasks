#include "main.h"

// Define the 7-segment display segments
uint8_t Seven_Segment_Char[10] = {
    0x3F,  // 0
    0x06,  // 1
    0x5B,  // 2
    0x4F,  // 3
    0x66,  // 4
    0x6D,  // 5
    0x7D,  // 6
    0x07,  // 7
    0x7F,  // 8
    0x6F   // 9
};

// External event counting variable
uint32_t button_press_count = 0;

// 7-segment GPIO pins (PB0-PB6 for segments A-G)
#define SEG_A   GPIO_PIN_0
#define SEG_B   GPIO_PIN_1
#define SEG_C   GPIO_PIN_2
#define SEG_D   GPIO_PIN_3
#define SEG_E   GPIO_PIN_4
#define SEG_F   GPIO_PIN_5
#define SEG_G   GPIO_PIN_6

// Function to display a number on the 7-segment display
void Display_On_7_Segment(uint8_t number)
{
    HAL_GPIO_WritePin(GPIOB, SEG_A, (Seven_Segment_Char[number] & 0x01) ? GPIO_PIN_SET : GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOB, SEG_B, (Seven_Segment_Char[number] & 0x02) ? GPIO_PIN_SET : GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOB, SEG_C, (Seven_Segment_Char[number] & 0x04) ? GPIO_PIN_SET : GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOB, SEG_D, (Seven_Segment_Char[number] & 0x08) ? GPIO_PIN_SET : GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOB, SEG_E, (Seven_Segment_Char[number] & 0x10) ? GPIO_PIN_SET : GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOB, SEG_F, (Seven_Segment_Char[number] & 0x20) ? GPIO_PIN_SET : GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOB, SEG_G, (Seven_Segment_Char[number] & 0x40) ? GPIO_PIN_SET : GPIO_PIN_RESET);
}

// Timer interrupt handler for counting external events (button presses)
void TIM2_IRQHandler(void)
{
    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_CC1) != RESET)
    {
        // Clear the capture flag
        __HAL_TIM_CLEAR_FLAG(&htim2, TIM_FLAG_CC1);

        // Increment button press count
        button_press_count++;

        // Update the 7-segment display with the new count
        Display_On_7_Segment(button_press_count % 10);  // Show the least significant digit

        // Optionally: Reset the counter after a certain number of presses (e.g., after 9)
        if (button_press_count >= 10)
        {
            button_press_count = 0;  // Reset after 9
        }
    }
}

// Main function
int main(void)
{
    HAL_Init();

    // System clock configuration (generated by STM32CubeMX)
    SystemClock_Config();

    // Initialize GPIO pins for 7-segment and button
    MX_GPIO_Init();

    // Initialize TIM2 for external event counting (PA5 as ETR)
    MX_TIM2_Init();

    // Start the timer in input capture mode for external trigger counting
    HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);

    while (1)
    {
        // Main loop: the counting and display updating is done in the interrupt
    }
}

// Timer initialization function (generated by STM32CubeMX)
static void MX_TIM2_Init(void)
{
    TIM_IC_InitTypeDef sConfigIC = {0};

    htim2.Instance = TIM2;
    htim2.Init.Prescaler = 0;
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim2.Init.Period = 0xFFFF;
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;

    if (HAL_TIM_IC_Init(&htim2) != HAL_OK)
    {
        Error_Handler();
    }

    // External trigger configuration for TIM2 (PA5 as ETR)
    sConfigIC.ICPolarity = TIM_ICPOLARITY_FALLING;  // Capture on falling edge (button press)
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
    sConfigIC.ICFilter = 0;

    if (HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
    {
        Error_Handler();
    }

    // Enable interrupt for TIM2
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
}

// Error handler
void Error_Handler(void)
{
    while (1)
    {
        // Stay here if there's an error
    }
}
